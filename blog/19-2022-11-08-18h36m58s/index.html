<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <title> | 领域逻辑的组织模式</title>
    
    <link rel="stylesheet" href="https://sdttttt.github.io/style.css?h=a56f213afcf5d255b64918e7a9e0f468ef1d0ac2954b49f36003998666482371">
    
</head>
<body>
    
<header class="space">
    <a href="https:&#x2F;&#x2F;sdttttt.github.io">&LeftArrow; Home</a>
</header>

    
<main>
    <h1>领域逻辑的组织模式</h1>
    
    <p class="secondary">3 April, 2020</p>
    
    <div class="space"></div>
    <p>目前领域逻辑的组织模式分为三种，“事务脚本”，“领域模型” 以及 “表模块”。</p>
<p><code>事务脚本</code>类似于<code>面向过程</code>编程，事务脚本有以下优点：</p>
<ul>
<li>它是一种大多数软件工程师都能理解的简单过程模型。</li>
<li>它能和一个行数据入口或表数据入口简单的数据源很好的协作。</li>
<li>非常容易设定事务的边界。</li>
</ul>
<p>一个组数据源操作便是一个独立的事务脚本。
当然事务脚本也存在很大的缺陷，当领域逻辑开始变得复杂时，这些缺点就开始暴露出来。
当几个事务要执行类似的逻辑时，通常几个脚本中会含有某些相同的代码。
通过将这些代码提取出来，来形成公共的子例程，来消除这种情况。
但是，很多时候消除副本会变得棘手，而检测副本则更困难，倒是消除副本后的程序反而比以前还要杂乱无章，难以维护。</p>
<p>复杂的领域逻辑，必然要引入对象，解决前面描述问题的面向对象方法就是<code>领域模型</code>。
一个内容管理系统会有用户，文章等类，进行鉴权，以及写入等逻辑均置于领域模型中。
因此，发布对象调用一次写入方法。
可能还会有其他例程来完成一些读取功能，但它其实都是调用领域模型中已有打方法实现的。</p>
<blockquote>
<p>领域模型的控制不再是由一个过程来控制用户某一个动作的逻辑，而是由每个对象都承担一部分相关逻辑。</p>
</blockquote>
<p>领域模型的开销来自于数据源的复杂度和使用上的复杂性，刚刚接触领域模型的人会需要时间来适应这种思维方式。一旦习惯了，你就会很爽！
另一方面你需要将数据源映射到领域模型上，数据源越是复杂，领域模型的效果就越是显著。</p>
<p><img src="/shiwujiaoben.png" alt="" /></p>
<p>上为事务脚本</p>
<p><img src="/lingyumoxing.png" alt="" /></p>
<p>上为领域模型</p>
<p>第三中为领域逻辑的组织模式为<code>表模块</code>，它处于<code>事务脚本</code>和<code>领域模型</code>的一个中间地带。
和领域模型最大的区别就是在表模块中一个表只对应一个实例，而领域模型一行数据便能对应一个实例。</p>
<p>表模块的优点在于可以很容易的和软件架构中已经存在的部分衔接，很多GUI应用都是假定将其与SQL查询结果的记录集结果协同工作的。表模块就工作在记录集之上。你可以很容易的使用。</p>
<p><img src="/tablemodule.png" alt="" /></p>
<h2 id="jue-ze">抉择</h2>
<p><img src="/modelfuzadu.png" alt="" /></p>
<p>别问，问就，直接使用领域模型。</p>
<p>接下来我稍微介绍一下目前各个框架/库在领域逻辑的组织模式上的选择（只列出我用）：</p>
<ul>
<li>
<p>PHP</p>
<ul>
<li>PHP 原生 &lt;事务脚本&gt;</li>
<li>ThinkPHP &lt;领域模型&gt;</li>
<li>Laravel &lt;领域模型&gt;</li>
<li>YII &lt;领域模型&gt;</li>
</ul>
</li>
<li>
<p>Java</p>
<ul>
<li>java.sql.* &lt;事务脚本&gt;</li>
<li>MyBatis &lt;表模块&gt;</li>
<li>JPA &lt;领域模型&gt;</li>
</ul>
</li>
<li>
<p>Go</p>
<ul>
<li>gorm &lt;表模块 | 领域模型&gt; （这个比较神奇）</li>
</ul>
</li>
</ul>
<p>现在用表模块的人普遍比较多，我曾遇到好几个J2EE工程师都并不喜欢<code>JPA</code>的思维模式。</p>

</main>

    <div class="dark-mode-buttons">
        <button class="dark-mode-button" id="dark-mode-on"><img src="https://sdttttt.github.io/dark_mode.svg" width="24" height="24" alt="Dark mode" aria-label="dark mode toggle" title="Dark mode"></button>
        <button class="dark-mode-button" id="dark-mode-off"><img src="https://sdttttt.github.io/light_mode.svg" width="24" height="24" alt="Light mode" aria-label="light mode toggle" title="Light mode"></button>
    </div>
    <script>
        const cls = document.body.classList;
        const getSessionTheme = sessionStorage.getItem("theme");
        if (getSessionTheme === "dark") {
            cls.toggle("dark-mode", true);
        } else if (getSessionTheme === "light") {
            cls.toggle("dark-mode", false);
        } else if (window.matchMedia("(prefers-color-scheme: dark)").matches) {
            cls.toggle("dark-mode", true);
        }

        document.getElementById("dark-mode-on").addEventListener("click", function(e) {
            cls.toggle("dark-mode", true);
            sessionStorage.setItem("theme", "dark");
        });
        document.getElementById("dark-mode-off").addEventListener("click", function(e) {
            cls.toggle("dark-mode", false);
            sessionStorage.setItem("theme", "light");
        });
    </script>
    <noscript>
        <style>
            .dark-mode-buttons {
                display: none;
            }
        </style>
    </noscript>
</body>
</html>
