---
title: "一致性哈希算法"
date: 2020-04-27T10:05:10+08:00
tags: ["distrbuted system"]
draft: false
---

第一代分布式系统采用的是中心化的系统，对于存贮大量数据的分布式系统来说它的缺点就是`中央节点`成为了整个个分布式系统的`单点故障`.

第二代分布式系统，节点之间通行采用的是`广播`，每个节点都向自己相连的`所有节点`进行询问，被询问的节点如果不知道这个文件在哪里,就再次进行`广播`......如此往复,直至找到所需文件。请求变多就意味着会产生`广播风暴`，这会严重占用带宽和系统资源。

第三代分布式系统开始采用`DHT`(Distrbuted Hash Table)，也就是`一致性HASH算法`.	

## 算法背景

一致性 HASH 算法在 1997 年由麻省理工学院的 Karger 等人在解决分布式 Cache 中提出的,设计目标是为了
解决因特网中的热点(Hot spot)问题,初衷和 CARP 十分类似。一致性 HASH 修正了 CARP 使用的简单哈希
算法带来的问题,使得 DHT 可以在 P2P 环境中真正得到应用。

但现在一致性 hash 算法在分布式系统中也得到了广泛应用,研究过 `memcached` 缓存数据库的人都知道,
`memcached` 服务器端本身不提供分布式 `Cache` 的一致性,而是由客户端来提供,具体在计算一致性 HASH 时采用如下步骤:

- 首先求出 memcached 服务器(节点)的哈希值,并将其配置到 `0 ~ 2^32` 的圆(continuum)上。

- 然后采用同样的方法求出存储数据的键的哈希值,并映射到相同的圆上。

- 然后从数据映射到的位置开始顺时针查找,将数据保存到找到的第一个服务器上。如果超过 2^32 仍然找不到服务器,就会保存到第一台 memcached 服务器上。

![](/ConsistentHashAlgorithm/1.png)

从上图的状态中添加一台 memcached 服务器。余数分布式算法由于保存键的服务器会发生巨大变化	
而影响缓存的命中率,但`一致性Hashing` 中,只有在圆(continuum)上增加服务器的地点逆时针方向	
的第一台服务器上的键会受到影响。

## 性质

因为考虑到整个系统的节点数量是动态的，每时每刻有新节点加入和旧节点的失效。	
在这类情况下依然要保证系统的可用性，这是值得思考的，尤其是在设计分布式缓存系统的时候。
如果不采用`一致性HASH算法`, 客户端在计算数据的 hash 时往往要重新计算(通常这个 Hash 算法和系统中的节点数量有关),
由于 Hash 值已经改变，所以很有可能找不到在整个系统中所对应的节点，导致不可用。所以`一致性HASH算法`，在分布式系统中十分重要。

良好的`一致性HASH算法`需要满足一下特点：


**平衡性(Balance)**

平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去,这样可以使得所有的缓冲空间都得到利用。很多哈希算法都能够满足这一条件。

**单调性(Monotonicity)**

单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中,又有新的缓冲区加入到系统中,那么哈 希的结果应能够保证原有已分配的内容可以被映射到新的缓冲区中去,而不会被映射到旧的缓冲集合中的 其他缓冲区。简单的哈希算法往往不能满足单调性的要求,如最简单的线性哈希:x = (ax + b) mod (P), 在上式中,P 表示全部缓冲的大小。不难看出,当缓冲大小发生变化时(从 P1 到 P2),原来所有的哈希结果 均会发生变化,从而不满足单调性的要求。哈希结果的变化意味着当缓冲空间发生变化时,所有的映射关 系需要在系统内全部更新。而在 P2P 系统内,缓冲的变化等价于 Peer 加入或退出系统,这一情况在 P2P 系 统中会频繁发生,因此会带来极大计算和传输负荷。单调性就是要求哈希算法能够应对这种情况。

**分散性(Spread)**

在分布式环境中,终端有可能看不到所有的缓冲,而是只能看到其中的一部分。当终端希望通过哈希过程 将内容映射到缓冲上时,由于不同终端所见的缓冲范围有可能不同,从而导致哈希的结果不一致,最终的 结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的,因为它导致相同内 容被存储到不同缓冲中去,降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈 希算法应能够尽量避免不一致的情况发生,也就是尽量降低分散性。

**负载(Load)**

负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区 中,那么对于一个特定的缓冲区而言,也可能被不同的用户映射为不同的内容。与分散性一样,这种情况 也是应当避免的,因此好的哈希算法应能够尽量降低缓冲的负荷。

**平滑性(Smoothness)**

平滑性是指缓存服务器的数目平滑改变和缓存对象的平滑改变是一致的。

## 虚拟节点

假设在圆上`Node A`和`Node B`距离过近，按照以上的环形一致 HASH 算法就会发生两个节点所拥有的数据数量不一致的问题。

![](/ConsistentHashAlgorithm/2.png)

为了解决这种数据倾斜问题，一致性哈希算法引入了虚拟节点机制，即对每一个服务节点计算`多个哈希`，每个计算结果位置都放置一个此`服务节点`，称为虚拟节点。具体做法可以在服务器 ip 或主机名的后面增加编号来实现。例如上面的情况，可以为每台服务器计算三个虚拟节点，于是可以分别计算 “Node A#1”、“Node A#2”、“Node A#3”、“Node B#1”、“Node B#2”、“Node B#3”的哈希值，于是形成六个虚拟节点：

同时数据定位算法不变，只是多了一步虚拟节点到实际节点的映射，例如定位到“Node A#1”、“Node A#2”、“Node A#3”三个虚拟节点的数据均定位到 Node A 上。这样就解决了服务节点少时数据倾斜的问题。在实际应用中，通常将虚拟节点数设置为 32 甚至更大，因此即使很少的服务节点也能做到相对均匀的数据分布。